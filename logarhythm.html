<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Formatter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Roboto, Arial, sans-serif;
            background: #0d0d0d;
            color: #e0e0e0;
            min-height: 100vh;
        }

        .app-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .editor-panel {
            width: 45%;
            min-width: 400px;
            background: #1a1a1a;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            padding: 16px 20px;
            background: #222;
            border-bottom: 1px solid #333;
        }

        .panel-header h2 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #fff;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .section {
            background: #222;
            border-radius: 8px;
            margin-bottom: 12px;
            overflow: hidden;
        }

        .section-header {
            padding: 12px 16px;
            background: #2a2a2a;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .section-header:hover {
            background: #333;
        }

        .section-header h3 {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .section-header .toggle-icon {
            transition: transform 0.2s;
        }

        .section-header.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        .section-content {
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .section-content.hidden {
            display: none;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary { background: #4a9eff; color: #fff; }
        .btn-primary:hover { background: #3a8eef; }
        .btn-secondary { background: #444; color: #e0e0e0; }
        .btn-secondary:hover { background: #555; }
        .btn-warning { background: #ff9f43; color: #000; }
        .btn-warning:hover { background: #ffaf53; }
        .btn-danger { background: #ff6b6b; color: #fff; }
        .btn-danger:hover { background: #ff5252; }
        .btn-success { background: #51cf66; color: #000; }
        .btn-success:hover { background: #40bf55; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-small { padding: 6px 12px; font-size: 0.8rem; }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .form-group label {
            font-size: 0.8rem;
            color: #aaa;
        }

        .form-row {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .form-row .form-group {
            flex: 1;
        }

        input[type="text"],
        input[type="number"],
        select,
        textarea {
            background: #333;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 8px 12px;
            color: #e0e0e0;
            font-size: 0.85rem;
            width: 100%;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: #4a9eff;
        }

        input[type="color"] {
            width: 40px;
            height: 32px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
        }

        .toggle-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle {
            position: relative;
            width: 44px;
            height: 24px;
            background: #444;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .toggle.active {
            background: #4a9eff;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active::after {
            transform: translateX(20px);
        }

        .toggle-label {
            font-size: 0.85rem;
        }

        .preview-panel {
            flex: 1;
            background: #111;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .preview-header {
            padding: 16px 20px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-header h2 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #fff;
        }

        .preview-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .preview-frame {
            min-height: 200px;
        }

        .edit-textarea {
            width: 100%;
            height: 100%;
            min-height: 400px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 16px;
            color: #e0e0e0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            resize: vertical;
        }

        .output-section {
            border-top: 1px solid #333;
            padding: 16px 20px;
            background: #1a1a1a;
        }

        .output-textarea {
            width: 100%;
            height: 150px;
            background: #222;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 12px;
            color: #e0e0e0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.8rem;
            resize: vertical;
            margin-bottom: 12px;
        }

        .style-property {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px;
            background: #2a2a2a;
            border-radius: 6px;
        }

        .style-property-label {
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
        }

        .style-property-input {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .style-property-input input,
        .style-property-input select {
            flex: 1;
        }

        .quote-mapping {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px;
            background: #2a2a2a;
            border-radius: 6px;
        }

        .quote-mapping .color-preview {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid #444;
        }

        .quote-mapping select {
            flex: 1;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.hidden {
            display: none;
        }

        .modal {
            background: #222;
            border-radius: 12px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
        }

        .modal h3 {
            margin-bottom: 16px;
            font-size: 1.1rem;
        }

        .modal p {
            margin-bottom: 20px;
            color: #aaa;
            font-size: 0.9rem;
        }

        .modal .btn-group {
            justify-content: flex-end;
        }

        .hidden {
            display: none !important;
        }

        .summary-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #2a2a2a;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .summary-input-group label {
            font-size: 0.8rem;
            color: #aaa;
            min-width: 80px;
        }

        .summary-input-group input {
            flex: 1;
        }

        .image-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .image-controls input[type="file"] {
            display: none;
        }
		
		.gradient-editor {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 8px;
    background: #333;
    border-radius: 4px;
    margin-top: 4px;
}
.pill-editor {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px;
    background: #2a2a2a;
    border-radius: 6px;
    margin-bottom: 8px;
    flex-wrap: wrap;
}

.pill-editor input[type="text"] {
    flex: 1;
    min-width: 100px;
}

.pill-editor input[type="color"] {
    width: 32px;
    height: 28px;
}

.pill-editor-colors {
    display: flex;
    align-items: center;
    gap: 4px;
}

.pill-editor-colors label {
    font-size: 0.7rem;
    color: #888;
}

.pill-preview {
    padding: 4px 12px;
    border-radius: 16px;
    font-size: 0.8rem;
    white-space: nowrap;
}
.gradient-stop {
    display: flex;
    align-items: center;
    gap: 8px;
}

.gradient-stop input[type="color"] {
    width: 32px;
    height: 24px;
}

.gradient-stop input[type="number"] {
    width: 60px;
}

.gradient-preview {
    height: 24px;
    border-radius: 4px;
    border: 1px solid #555;
    margin-top: 4px;
}

.border-editor {
    display: flex;
    gap: 8px;
    align-items: center;
    flex-wrap: wrap;
}

.border-editor input[type="number"] {
    width: 60px;
}

.border-editor select {
    width: 100px;
}

.border-editor input[type="color"] {
    width: 32px;
    height: 28px;
}

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Left Panel - Editor -->
        <div class="editor-panel">
            <div class="panel-header">
                <h2>Editor</h2>
            </div>
            <div class="panel-content">
                <!-- Import Data Section -->
                <div class="section">
                    <div class="section-header" onclick="toggleSection(this)">
                        <h3>üìã Import Data</h3>
                        <span class="toggle-icon">‚ñº</span>
                    </div>
                    <div class="section-content">
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="handlePaste()">Paste</button>
                            <button class="btn btn-secondary" onclick="handleAdd()" id="addBtn" disabled>Add</button>
                        </div>
                        <div class="form-group" style="margin-top: 12px;">
                            <label>Or paste HTML here manually:</label>
                            <textarea id="manualPasteInput" rows="4" placeholder="Paste your HTML content here..."></textarea>
                            <button class="btn btn-secondary btn-small" onclick="handleManualPaste()" style="margin-top: 8px;">Import from textarea</button>
                        </div>
                    </div>
                </div>

                <!-- Header Data Section -->
 <div class="section">
    <div class="section-header" onclick="toggleSection(this)">
        <h3>üìù Header Data</h3>
        <span class="toggle-icon">‚ñº</span>
    </div>
    <div class="section-content">
        <div class="form-group">
            <label>Card Name</label>
            <input type="text" id="cardNameInput" placeholder="Character name..." oninput="updatePreview()">
        </div>
        
        <div class="form-group">
            <label>Pills / Badges</label>
            <div id="pillsContainer"></div>
            <button class="btn btn-secondary btn-small" onclick="addPill()" style="margin-top: 8px;">+ Add Pill</button>
        </div>
        
        <div class="form-group">
            <label>Profile Image</label>
            <div class="image-controls">
                <button class="btn btn-secondary btn-small" onclick="document.getElementById('imageUpload').click()">Upload</button>
                <button class="btn btn-danger btn-small" onclick="removeImage()">Remove</button>
                <input type="file" id="imageUpload" accept="image/*" onchange="handleImageUpload(event)">
            </div>
        </div>
    </div>
</div>

                <!-- Search & Replace Section -->
                <div class="section">
                    <div class="section-header" onclick="toggleSection(this)">
                        <h3>üîç Search & Replace</h3>
                        <span class="toggle-icon">‚ñº</span>
                    </div>
                    <div class="section-content">
                        <div class="form-row">
                            <div class="form-group">
                                <label>Find</label>
                                <input type="text" id="searchInput" placeholder="Text to find...">
                            </div>
                            <div class="form-group">
                                <label>Replace with</label>
                                <input type="text" id="replaceInput" placeholder="Replacement text...">
                            </div>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-warning" onclick="executeReplace()">Replace All</button>
                            <button class="btn btn-secondary" onclick="undoReplace()" id="undoBtn" disabled>Undo</button>
                        </div>
                    </div>
                </div>

                <!-- Quote Color Mapping Section -->
                <div class="section">
                    <div class="section-header" onclick="toggleSection(this)">
                        <h3>üé® Quote Color Mapping</h3>
                        <span class="toggle-icon">‚ñº</span>
                    </div>
                    <div class="section-content" id="quoteColorMappings">
                        <p style="font-size: 0.8rem; color: #888;">Detected quote colors will appear here after pasting content.</p>
                    </div>
                </div>

                <!-- Collapsible Sections -->
                <div class="section">
                    <div class="section-header" onclick="toggleSection(this)">
                        <h3>üìÇ Collapsible Sections</h3>
                        <span class="toggle-icon">‚ñº</span>
                    </div>
                    <div class="section-content">
                        <div class="toggle-group">
                            <div class="toggle" id="detailsToggle" onclick="toggleDetails()"></div>
                            <span class="toggle-label">Wrap blocks in &lt;details&gt;</span>
                        </div>
                        <div id="summaryInputs" style="margin-top: 12px; display: none;"></div>
                    </div>
                </div>

                <!-- Global Styles Section -->
                <div class="section">
                    <div class="section-header" onclick="toggleSection(this)">
                        <h3>üåê Global Styles</h3>
                        <span class="toggle-icon">‚ñº</span>
                    </div>
                    <div class="section-content">
                        <div class="form-group">
                            <label>Font Family</label>
                            <select id="globalFont" onchange="updateGlobalFont()">
                                <option value="'Segoe UI', Roboto, Arial, sans-serif">Segoe UI / Roboto</option>
                                <option value="Arial, Helvetica, sans-serif">Arial</option>
                                <option value="Georgia, 'Times New Roman', serif">Georgia</option>
                                <option value="'Times New Roman', Times, serif">Times New Roman</option>
                                <option value="'Courier New', Courier, monospace">Courier New</option>
                                <option value="Verdana, Geneva, sans-serif">Verdana</option>
                            </select>
                        </div>
                        <div class="toggle-group">
                            <div class="toggle" id="oddEvenToggle" onclick="toggleOddEven()"></div>
                            <span class="toggle-label">Split Odd/Even Block Styles</span>
                        </div>
                    </div>
                </div>

                <!-- Style Editors (generated dynamically) -->
                <div id="styleEditors"></div>

                <!-- Templates & Presets Section -->
                <div class="section">
                    <div class="section-header" onclick="toggleSection(this)">
                        <h3>üíæ Templates & Presets</h3>
                        <span class="toggle-icon">‚ñº</span>
                    </div>
                    <div class="section-content">
                        <div class="form-group">
                            <label>Load Template</label>
                            <select id="presetSelect">
                                <option value="">-- Select Template --</option>
                            </select>
                        </div>
                        <div style="margin: 12px 0; padding: 12px; background: #2a2a2a; border-radius: 6px;">
                            <p style="font-size: 0.8rem; color: #888; margin-bottom: 8px;">
                                Current: <strong id="currentTemplateName">Vertical Dark</strong>
                            </p>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-success" onclick="downloadCurrentTemplate()">Download Template</button>
                            <button class="btn btn-secondary" onclick="document.getElementById('templateUpload').click()">Upload Template</button>
                            <input type="file" id="templateUpload" accept=".json" style="display: none;" onchange="uploadTemplate(event)">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel - Preview -->
        <div class="preview-panel">
            <div class="preview-header">
                <h2 id="previewTitle">Preview</h2>
                <div class="btn-group">
                    <button class="btn btn-secondary" id="editBtn" onclick="toggleEditMode()">Edit HTML</button>
                </div>
            </div>
            <div class="preview-content">
                <div class="preview-frame" id="previewFrame">
                    <p style="color: #666; text-align: center; padding: 40px;">Paste content to see preview</p>
                </div>
                <textarea class="edit-textarea hidden" id="editTextarea" oninput="updateFromEdit()"></textarea>
            </div>
            <div class="output-section">
                <button class="btn btn-success" onclick="generateOutput()" style="margin-bottom: 12px;">Generate Output</button>
                <textarea class="output-textarea" id="outputTextarea" readonly placeholder="Click 'Generate Output' to see the final HTML..."></textarea>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="copyOutput(event)">Copy to Clipboard</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="modal-overlay hidden" id="confirmModal">
        <div class="modal">
            <h3>‚ö†Ô∏è Overwrite Data?</h3>
            <p>You already have content. Pasting will replace all existing data. Continue?</p>
            <div class="btn-group">
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                <button class="btn btn-danger" onclick="confirmPaste()">Overwrite</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // STATE MANAGEMENT
        // ============================================
        
        const state = {
            textBlocks: [],
            cardName: '',
    pills: [], // ADD THIS - array of {text: '', color: '', bgColor: ''}
            imageData: '',
            hasContent: false,
            isEditMode: false,
            isOddEvenMode: false,
            isDetailsMode: false,
            summaryTexts: [],
            quoteColorMap: {},
            detectedColors: new Set(),
            searchReplaceBackup: null,
            currentTemplate: 'vertical_dark',
            templateStyles: {},
            globalFont: "'Segoe UI', Roboto, Arial, sans-serif"
        };

        // ============================================
        // QUOTE COLOR DEFINITIONS
        // ============================================
        
        const QUOTE_COLORS = {
            '#8BE9FD': 'smallquote',
            '#FFB86C': 'bigquote'
        };

        const PARAGRAPH_COLORS = ['#F8F8F2', '#FFFFFF', '#E0E0E0', '#D4D4D4', '#CCCCCC'];

        // ============================================
        // TEMPLATE DEFINITIONS
        // ============================================

        const templateDefinitions = {
            elements: {
                root_container: { label: 'Root Container', description: 'The outermost wrapper' },
                image_container: { label: 'Image Container', description: 'Wrapper for the profile image' },
                content_container: { label: 'Content Container', description: 'Wrapper for all text content' },
                header_container: { label: 'Header Container', description: 'Contains card name and pills' },
                card_name: { label: 'Card Name', description: 'Character/card name text' },
                text_container: { label: 'Text Container', description: 'Wrapper for all text blocks' },
                text_block: { label: 'Text Block', description: 'Individual message block', supportsOddEven: true },
                paragraph: { label: 'Paragraph', description: 'Normal narrative text', supportsOddEven: true },
                smallquote: { label: 'Small Quote', description: 'Inner thoughts, whispers', supportsOddEven: true },
                bigquote: { label: 'Big Quote', description: 'Speech, dialogue', supportsOddEven: true },
                footer_container: { label: 'Footer Container', description: 'Footer wrapper' },
                footer_text: { label: 'Footer Text', description: 'Attribution text' }
            }
        };

        // ============================================
        // TEMPLATE PRESETS
        // ============================================

        const templatePresets = {
            vertical_dark: {
                name: 'Vertical Dark',
                description: 'Image on top, content below',
                structure: 'vertical',
                styles: {
                    root_container: {
                        'background': '#000000',
                        'border': '0 solid #4b5563',
                        'border-radius': '12px',
                        'padding': '20px',
                        'margin': '1rem auto',
                        'max-width': '600px',
                        'box-shadow': '0px 4px 12px rgba(0,0,0,0.15)',
                        'display': 'flex',
                        'flex-direction': 'column',
                        'align-items': 'center'
                    },
                    image_container: {
                        'width': '80px',
                        'height': '80px',
                        'border-radius': '50%',
                        'border': '3px solid #4b5563',
                        'background-size': 'cover',
                        'background-position': 'center',
                        'background-repeat': 'no-repeat',
                        'margin-bottom': '1rem'
                    },
                    content_container: { 'width': '100%' },
                    header_container: {
                        'display': 'flex',
                        'flex-direction': 'column',
                        'align-items': 'center',
                        'margin-bottom': '1rem'
                    },
                    card_name: { 'color': '#f8f8f2', 'font-size': '1.5rem', 'font-weight': '600', 'margin': '0' },
                    llm_badge: {
                        'background': '#000000',
                        'color': '#f8f8f2',
                        'border': '1px solid #4b5563',
                        'border-radius': '16px',
                        'padding': '0.25rem 0.75rem',
                        'font-size': '0.8rem',
                        'margin-top': '0.5rem',
                        'display': 'inline-block'
                    },
                    text_container: { 'border-top': '1px solid #4b5563', 'padding-top': '1rem' },
                    text_block: { 'background': 'transparent', 'border': '0 solid #4b5563', 'border-radius': '0', 'padding': '0', 'margin': '0 0 1rem 0' },
                    paragraph: { 'color': '#f8f8f2', 'font-size': '1rem', 'line-height': '1.6', 'padding': '0', 'margin': '0' },
                    smallquote: { 'color': '#8BE9FD', 'background': 'transparent', 'font-style': 'normal', 'padding': '0', 'margin': '0', 'border': '0 none #8BE9FD' },
                    bigquote: { 'color': '#FFB86C', 'background': 'transparent', 'font-style': 'normal', 'padding': '0', 'margin': '0', 'border': '0 none #FFB86C' },
                    footer_container: { 'border-top': '1px solid #4b5563', 'padding-top': '0.75rem', 'text-align': 'center', 'margin-top': '1rem' },
                    footer_text: { 'color': '#64748b', 'font-size': '0.75rem', 'opacity': '0.7' }
                }
            },
            horizontal_dark: {
                name: 'Horizontal Dark',
                description: 'Image on left, content on right',
                structure: 'horizontal',
                styles: {
                    root_container: {
                        'background': '#000000',
                        'border': '1px solid #4b5563',
                        'border-radius': '16px 12px 12px 16px',
                        'padding': '10px',
                        'margin': '1rem auto',
                        'max-width': '700px',
                        'box-shadow': '0px 4px 12px rgba(0,0,0,0.15)',
                        'display': 'flex',
                        'flex-direction': 'row'
                    },
                    image_container: {
                        'width': '200px',
                        'min-height': '300px',
                        'border-radius': '8px 0 0 8px',
                        'background-size': 'cover',
                        'background-position': 'center',
                        'background-repeat': 'no-repeat',
                        'flex-shrink': '0'
                    },
                    content_container: { 'flex': '1', 'padding': '1rem', 'margin-left': '10px' },
                    header_container: { 'display': 'flex', 'align-items': 'start', 'justify-content': 'space-between', 'margin-bottom': '1rem' },
                    card_name: { 'color': '#f8f8f2', 'font-size': '1.5rem', 'font-weight': '600', 'margin': '0' },
                    llm_badge: { 'background': '#000000', 'color': '#f8f8f2', 'border': '1px solid #4b5563', 'border-radius': '16px', 'padding': '0.25rem 0.75rem', 'font-size': '0.8rem', 'display': 'inline-block' },
                    text_container: { 'padding': '0' },
                    text_block: { 'background': 'transparent', 'border': '0 solid #4b5563', 'border-radius': '0', 'padding': '0', 'margin': '0 0 1rem 0' },
                    text_block_even: { 'background': '#9c7373', 'border': '0 solid #4b5563', 'border-radius': '5px', 'padding': '5px', 'margin': '0 0 1rem 0' },
                    paragraph: { 'color': '#f8f8f2', 'font-size': '1rem', 'line-height': '1.6', 'padding': '0', 'margin': '0' },
                    smallquote: { 'color': '#8BE9FD', 'background': 'transparent', 'font-style': 'normal', 'padding': '0', 'margin': '0', 'border': '0 none #8BE9FD' },
                    bigquote: { 'color': '#FFB86C', 'background': 'transparent', 'font-style': 'normal', 'padding': '0', 'margin': '0', 'border': '0 none #FFB86C' },
                    footer_container: { 'border-top': '1px solid #4b5563', 'padding-top': '0.75rem', 'text-align': 'center', 'margin-top': '1rem' },
                    footer_text: { 'color': '#64748b', 'font-size': '0.75rem', 'opacity': '0.7' }
                }
            },
            horizontal_light: {
                name: 'Horizontal Light',
                description: 'Image on left, light theme',
                structure: 'horizontal',
                styles: {
                    root_container: { 'background': '#ffffff', 'border': '1px solid #e0e0e0', 'border-radius': '16px 12px 12px 16px', 'padding': '10px', 'margin': '1rem auto', 'max-width': '700px', 'box-shadow': '0px 4px 12px rgba(0,0,0,0.08)', 'display': 'flex', 'flex-direction': 'row' },
                    image_container: { 'width': '200px', 'min-height': '300px', 'border-radius': '8px 0 0 8px', 'background-size': 'cover', 'background-position': 'center', 'background-repeat': 'no-repeat', 'flex-shrink': '0' },
                    content_container: { 'flex': '1', 'padding': '1rem', 'margin-left': '10px' },
                    header_container: { 'display': 'flex', 'align-items': 'start', 'justify-content': 'space-between', 'margin-bottom': '1rem' },
                    card_name: { 'color': '#1a1a1a', 'font-size': '1.5rem', 'font-weight': '600', 'margin': '0' },
                    llm_badge: { 'background': '#f5f5f5', 'color': '#333333', 'border': '1px solid #d0d0d0', 'border-radius': '16px', 'padding': '0.25rem 0.75rem', 'font-size': '0.8rem', 'display': 'inline-block' },
                    text_container: { 'padding': '0' },
                    text_block: { 'background': 'transparent', 'border': '0 solid #e0e0e0', 'border-radius': '0', 'padding': '0', 'margin': '0 0 1rem 0' },
                    paragraph: { 'color': '#1a1a1a', 'font-size': '1rem', 'line-height': '1.6', 'padding': '0', 'margin': '0' },
                    smallquote: { 'color': '#0891b2', 'background': 'transparent', 'font-style': 'normal', 'padding': '0', 'margin': '0', 'border': '0 none #0891b2' },
                    bigquote: { 'color': '#d97706', 'background': 'transparent', 'font-style': 'normal', 'padding': '0', 'margin': '0', 'border': '0 none #d97706' },
                    footer_container: { 'border-top': '1px solid #e0e0e0', 'padding-top': '0.75rem', 'text-align': 'center', 'margin-top': '1rem' },
                    footer_text: { 'color': '#6b7280', 'font-size': '0.75rem', 'opacity': '0.7' }
                }
            }
        };

        // ============================================
        // UI HELPERS
        // ============================================

        function toggleSection(header) {
            header.classList.toggle('collapsed');
            const content = header.nextElementSibling;
            content.classList.toggle('hidden');
        }

        function closeModal() {
            document.getElementById('confirmModal').classList.add('hidden');
        }

        function updateGlobalFont() {
            state.globalFont = document.getElementById('globalFont').value;
            updatePreview();
        }

        // ============================================
        // TEMPLATE MANAGEMENT
        // ============================================

        function loadTemplate(templateKey) {
            if (!templatePresets[templateKey]) return;
            
            state.currentTemplate = templateKey;
            state.templateStyles = JSON.parse(JSON.stringify(templatePresets[templateKey].styles));
            
            document.getElementById('currentTemplateName').textContent = templatePresets[templateKey].name;
            
            generateStyleEditors();
            updatePreview();
        }

        function updatePresetDropdown() {
            const select = document.getElementById('presetSelect');
            select.innerHTML = '<option value="">-- Select Template --</option>';
            
            for (const [key, preset] of Object.entries(templatePresets)) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = `${preset.name} - ${preset.description}`;
                select.appendChild(option);
            }
        }

        function downloadCurrentTemplate() {
            const template = {
                name: 'Custom Template',
                description: 'Exported from Text Formatter',
                structure: templatePresets[state.currentTemplate]?.structure || 'vertical',
                styles: state.templateStyles,
                globalFont: state.globalFont,
                isOddEvenMode: state.isOddEvenMode
            };
            
            const blob = new Blob([JSON.stringify(template, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'text-formatter-template.json';
            a.click();
            
            URL.revokeObjectURL(url);
        }

        function uploadTemplate(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const template = JSON.parse(e.target.result);
                    
                    const customKey = 'custom_' + Date.now();
                    templatePresets[customKey] = {
                        name: template.name || 'Custom',
                        description: template.description || 'Imported template',
                        structure: template.structure || 'vertical',
                        styles: template.styles
                    };
                    
                    state.currentTemplate = customKey;
                    state.templateStyles = JSON.parse(JSON.stringify(template.styles));
                    state.globalFont = template.globalFont || state.globalFont;
                    state.isOddEvenMode = template.isOddEvenMode || false;
                    
                    document.getElementById('currentTemplateName').textContent = template.name || 'Custom';
                    
                    updatePresetDropdown();
                    generateStyleEditors();
                    updatePreview();
                    
                    alert('Template loaded successfully!');
                } catch (err) {
                    console.error('Failed to parse template:', err);
                    alert('Invalid template file.');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // ============================================
        // STYLE EDITOR GENERATION
        // ============================================

        function generateStyleEditors() {
            const container = document.getElementById('styleEditors');
            container.innerHTML = '';
            
            for (const [elementKey, elementDef] of Object.entries(templateDefinitions.elements)) {
                if (elementKey.endsWith('_even')) continue;
                
                const section = createStyleSection(elementKey, elementDef);
                container.appendChild(section);
                
                if (elementDef.supportsOddEven && state.isOddEvenMode) {
                    const evenSection = createStyleSection(elementKey + '_even', {
                        ...elementDef,
                        label: elementDef.label + ' (Even)'
                    });
                    container.appendChild(evenSection);
                }
            }
        }

        function createStyleSection(elementKey, elementDef) {
            const section = document.createElement('div');
            section.className = 'section';
            section.id = `section_${elementKey}`;
            
            const styles = state.templateStyles[elementKey] || {};
            const labelSuffix = elementDef.supportsOddEven && state.isOddEvenMode && !elementKey.endsWith('_even') ? ' (Odd)' : '';
            
            let propertiesHTML = '';
            for (const [prop, value] of Object.entries(styles)) {
                propertiesHTML += createPropertyInput(elementKey, prop, value);
            }
            
            section.innerHTML = `
                <div class="section-header" onclick="toggleSection(this)">
                    <h3>üé® ${elementDef.label}${labelSuffix}</h3>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="section-content">
                    <p style="font-size: 0.75rem; color: #666; margin-bottom: 12px;">${elementDef.description || ''}</p>
                    ${propertiesHTML}
                    <div class="btn-group" style="margin-top: 12px;">
                        <button class="btn btn-secondary btn-small" onclick="addProperty('${elementKey}')">+ Add Property</button>
                    </div>
                </div>
            `;
            
            return section;
        }
function createPropertyInput(elementKey, prop, value) {
    const isColor = (prop === 'color' || prop === 'background-color' || prop === 'background');
    const isBorder = prop === 'border';
    const isBackground = (prop === 'background' || prop === 'background-color');
    
    let inputHTML = '';
    
    if (isBorder) {
        // Parse existing border value: "1px solid #4b5563"
        const borderMatch = (value || '').match(/^(\d+)px\s+(\w+)\s+(#[a-fA-F0-9]{6}|#[a-fA-F0-9]{3}|[a-zA-Z]+)$/);
        const width = borderMatch ? borderMatch[1] : '1';
        const style = borderMatch ? borderMatch[2] : 'solid';
        const color = borderMatch ? borderMatch[3] : '#4b5563';
        
        inputHTML = `
            <div class="border-editor">
                <input type="number" value="${width}" min="0" max="20" 
                    onchange="updateBorderStyle('${elementKey}', '${prop}', this.parentElement)">
                <span>px</span>
                <select onchange="updateBorderStyle('${elementKey}', '${prop}', this.parentElement)">
                    <option value="none" ${style === 'none' ? 'selected' : ''}>none</option>
                    <option value="solid" ${style === 'solid' ? 'selected' : ''}>solid</option>
                    <option value="dashed" ${style === 'dashed' ? 'selected' : ''}>dashed</option>
                    <option value="dotted" ${style === 'dotted' ? 'selected' : ''}>dotted</option>
                    <option value="double" ${style === 'double' ? 'selected' : ''}>double</option>
                </select>
                <input type="color" value="${color.startsWith('#') ? color : '#4b5563'}" 
                    onchange="updateBorderStyle('${elementKey}', '${prop}', this.parentElement)">
            </div>
        `;
    } else if (isBackground) {
        // Check if it's a gradient or solid color
        const isGradient = value && value.includes('gradient');
        const solidColor = (!value || value.startsWith('#')) ? (value || '#000000') : '#000000';
        
        inputHTML = `
            <div class="background-type-selector">
                <select onchange="toggleBackgroundType('${elementKey}', '${prop}', this.value, this.parentElement)">
                    <option value="solid" ${!isGradient ? 'selected' : ''}>Solid Color</option>
                    <option value="gradient" ${isGradient ? 'selected' : ''}>Gradient</option>
                </select>
                <div class="solid-color-editor" style="${isGradient ? 'display:none' : ''}">
                    <input type="color" value="${solidColor}" 
                        onchange="updateTemplateStyle('${elementKey}', '${prop}', this.value)">
                    <input type="text" value="${!isGradient ? value || '' : ''}" 
                        onchange="updateTemplateStyle('${elementKey}', '${prop}', this.value)">
                </div>
                <div class="gradient-editor" style="${!isGradient ? 'display:none' : ''}" data-element="${elementKey}" data-prop="${prop}">
                    <select class="gradient-type" onchange="updateGradient('${elementKey}', '${prop}')">
                        <option value="linear" ${value?.includes('linear') ? 'selected' : ''}>Linear</option>
                        <option value="radial" ${value?.includes('radial') ? 'selected' : ''}>Radial</option>
                    </select>
                    <div class="gradient-direction" style="${value?.includes('radial') ? 'display:none' : ''}">
                        <label style="font-size: 0.75rem;">Angle:</label>
                        <input type="number" class="gradient-angle" value="${parseGradientAngle(value)}" min="0" max="360" 
                            onchange="updateGradient('${elementKey}', '${prop}')">
                        <span>deg</span>
                    </div>
                    <div class="gradient-stops">
                        ${generateGradientStops(elementKey, prop, value)}
                    </div>
                    <button class="btn btn-secondary btn-small" onclick="addGradientStop('${elementKey}', '${prop}')">+ Add Stop</button>
                    <div class="gradient-preview" style="background: ${isGradient ? value : 'linear-gradient(90deg, #000 0%, #fff 100%)'}"></div>
                </div>
            </div>
        `;
    } else if (isColor) {
        const colorValue = (value && value.startsWith('#')) ? value : '#000000';
        inputHTML = `
            <input type="color" value="${colorValue}" onchange="updateTemplateStyle('${elementKey}', '${prop}', this.value)">
            <input type="text" value="${value || ''}" onchange="updateTemplateStyle('${elementKey}', '${prop}', this.value)">
        `;
    } else {
        inputHTML = `<input type="text" value="${value || ''}" onchange="updateTemplateStyle('${elementKey}', '${prop}', this.value)">`;
    }
    
    return `
        <div class="style-property">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span class="style-property-label">${prop}</span>
                <button class="btn btn-danger btn-small" style="padding: 2px 6px; font-size: 0.7rem;" onclick="removeProperty('${elementKey}', '${prop}')">√ó</button>
            </div>
            <div class="style-property-input">${inputHTML}</div>
        </div>
    `;
}
        function updateTemplateStyle(elementKey, property, value) {
            if (!state.templateStyles[elementKey]) {
                state.templateStyles[elementKey] = {};
            }
            state.templateStyles[elementKey][property] = value;
            updatePreview();
        }

        function removeProperty(elementKey, property) {
            if (state.templateStyles[elementKey]) {
                delete state.templateStyles[elementKey][property];
                generateStyleEditors();
                updatePreview();
            }
        }

        function addProperty(elementKey) {
            const prop = prompt('Enter CSS property name (e.g., margin, padding, border):');
            if (!prop) return;
            
            const value = prompt('Enter value:');
            if (value === null) return;
            
            if (!state.templateStyles[elementKey]) {
                state.templateStyles[elementKey] = {};
            }
            state.templateStyles[elementKey][prop.trim()] = value.trim();
            
            generateStyleEditors();
            updatePreview();
        }

        // ============================================
        // PASTE & ADD HANDLING
        // ============================================

        async function handlePaste() {
            if (state.hasContent) {
                document.getElementById('confirmModal').classList.remove('hidden');
                return;
            }
            await executePaste();
        }

        async function confirmPaste() {
            closeModal();
            await executePaste();
        }

        function handleManualPaste() {
            const html = document.getElementById('manualPasteInput').value;
            
            if (!html.trim()) {
                alert('Please paste some content first.');
                return;
            }
            
            const parsed = parseInputHTML(html);
            
            if (parsed) {
                state.textBlocks = [parsed.textContent];
                state.cardName = parsed.cardName;
                state.imageData = parsed.imageData;
                state.hasContent = true;
                state.summaryTexts = ['Section 1'];
                
                document.getElementById('cardNameInput').value = state.cardName;
                document.getElementById('addBtn').disabled = false;
                
                updateQuoteColorMappings();
                updateSummaryInputs();
                updatePreview();
                
                document.getElementById('manualPasteInput').value = '';
            } else {
                alert('Could not parse the content. Make sure it contains valid HTML.');
            }
        }

        async function executePaste() {
            try {
                let html = '';
                
                if (navigator.clipboard.read) {
                    try {
                        const clipboardItems = await navigator.clipboard.read();
                        
                        for (const item of clipboardItems) {
                            if (item.types.includes('text/html')) {
                                const blob = await item.getType('text/html');
                                html = await blob.text();
                                break;
                            }
                        }
                        
                        if (!html) {
                            for (const item of clipboardItems) {
                                if (item.types.includes('text/plain')) {
                                    const blob = await item.getType('text/plain');
                                    html = await blob.text();
                                    break;
                                }
                            }
                        }
                    } catch (readError) {
                        html = await navigator.clipboard.readText();
                    }
                } else {
                    html = await navigator.clipboard.readText();
                }
                
                if (!html) {
                    alert('No content found in clipboard.');
                    return;
                }
                
                const parsed = parseInputHTML(html);
                
                if (parsed) {
                    state.textBlocks = [parsed.textContent];
                    state.cardName = parsed.cardName;
					state.pills = parsed.pills || [];
                    state.imageData = parsed.imageData;
                    state.hasContent = true;
                    state.summaryTexts = ['Section 1'];
                    
                    document.getElementById('cardNameInput').value = state.cardName;
                    document.getElementById('addBtn').disabled = false;
                    
					renderPills();
                    updateQuoteColorMappings();
                    updateSummaryInputs();
                    updatePreview();
                } else {
                    alert('Could not parse the pasted content.');
                }
            } catch (err) {
                console.error('Failed to read clipboard:', err);
                alert('Failed to read clipboard.');
            }
        }

        async function handleAdd() {
            if (!state.hasContent) return;
            
            try {
                let html = '';
                
                if (navigator.clipboard.read) {
                    try {
                        const clipboardItems = await navigator.clipboard.read();
                        
                        for (const item of clipboardItems) {
                            if (item.types.includes('text/html')) {
                                const blob = await item.getType('text/html');
                                html = await blob.text();
                                break;
                            }
                        }
                        
                        if (!html) {
                            for (const item of clipboardItems) {
                                if (item.types.includes('text/plain')) {
                                    const blob = await item.getType('text/plain');
                                    html = await blob.text();
                                    break;
                                }
                            }
                        }
                    } catch (readError) {
                        html = await navigator.clipboard.readText();
                    }
                } else {
                    html = await navigator.clipboard.readText();
                }
                
                const parsed = parseInputHTML(html);
                
                if (parsed) {
                    state.textBlocks.push(parsed.textContent);
                    state.summaryTexts.push(`Section ${state.textBlocks.length}`);
                    
                    updateQuoteColorMappings();
                    updateSummaryInputs();
                    updatePreview();
                }
            } catch (err) {
                console.error('Failed to read clipboard:', err);
                alert('Failed to read clipboard.');
            }
        }

        // ============================================
        // HTML PARSING
        // ============================================

        function parseInputHTML(html) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            const container = doc.querySelector('div[style*="font-family"]') || doc.querySelector('div');
            if (!container) return null;
            
            const cardNameEl = container.querySelector('h3');
            const cardName = cardNameEl ? cardNameEl.textContent.trim() : '';
            
    // Parse pills - look for spans with border-radius: 16px
    const pillElements = container.querySelectorAll('span[style*="border-radius: 16px"], span[style*="inline-block"]');
    const pills = [];
                
    pillElements.forEach(el => {
        const style = el.getAttribute('style') || '';
        const text = el.textContent.trim();
        
        // Extract colors from style
        const bgMatch = style.match(/background:\s*(#[a-fA-F0-9]{6}|#[a-fA-F0-9]{3})/i);
        const colorMatch = style.match(/(?:^|;)\s*color:\s*(#[a-fA-F0-9]{6}|#[a-fA-F0-9]{3})/i);
        const borderMatch = style.match(/border:\s*\d+px\s+\w+\s+(#[a-fA-F0-9]{6}|#[a-fA-F0-9]{3})/i);
        
        pills.push({
            text: text,
            bgColor: bgMatch ? bgMatch[1] : '#000000',
            textColor: colorMatch ? colorMatch[1] : '#f8f8f2',
            borderColor: borderMatch ? borderMatch[1] : '#4b5563'
        });
    });
            const imgEl = container.querySelector('img');
            const imageData = imgEl ? imgEl.src : '';
            
            const textContainer = container.querySelector('div[style*="border-top"]');
            const textContent = parseTextContent(textContainer || container);
            
            return { cardName, pills, imageData, textContent };
        }

        function parseTextContent(container) {
            if (!container) return [];
            
            const elements = [];
            const children = container.children;
            
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                const text = child.textContent.trim();
                
                if (!text) continue;
                
                const style = child.getAttribute('style') || '';
                const colorMatch = style.match(/(?:^|;)\s*color:\s*(#[a-fA-F0-9]{6}|#[a-fA-F0-9]{3}|rgb\([^)]+\)|[a-zA-Z]+)/i);
                
                if (colorMatch) {
                    const color = normalizeColor(colorMatch[1]);
                    
                    if (QUOTE_COLORS[color]) {
                        state.detectedColors.add(color);
                        
                        if (!state.quoteColorMap[color]) {
                            state.quoteColorMap[color] = QUOTE_COLORS[color];
                        }
                        
                        elements.push({ 
                            type: 'quote', 
                            quoteType: state.quoteColorMap[color],
                            originalColor: color,
                            content: text 
                        });
                    } else if (isParagraphColor(color)) {
                        elements.push({ type: 'paragraph', content: text });
                    } else {
                        state.detectedColors.add(color);
                        
                        if (!state.quoteColorMap[color]) {
                            state.quoteColorMap[color] = 'unknown';
                        }
                        
                        elements.push({ 
                            type: 'quote', 
                            quoteType: state.quoteColorMap[color],
                            originalColor: color,
                            content: text 
                        });
                    }
                } else {
                    elements.push({ type: 'paragraph', content: text });
                }
            }
            
            return elements;
        }

        function normalizeColor(color) {
            color = color.trim().toUpperCase();
            
            if (color.startsWith('RGB')) {
                const match = color.match(/RGB\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i);
                if (match) {
                    const r = parseInt(match[1]).toString(16).padStart(2, '0');
                    const g = parseInt(match[2]).toString(16).padStart(2, '0');
                    const b = parseInt(match[3]).toString(16).padStart(2, '0');
                    color = `#${r}${g}${b}`.toUpperCase();
                }
            }
            
            if (color.match(/^#[A-F0-9]{3}$/)) {
                color = `#${color[1]}${color[1]}${color[2]}${color[2]}${color[3]}${color[3]}`;
            }
            
            return color;
        }

        function isParagraphColor(color) {
            if (PARAGRAPH_COLORS.includes(color)) return true;
            
            const hex = color.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            const isLight = r > 200 && g > 200 && b > 200;
            const isSimilar = Math.abs(r - g) < 20 && Math.abs(g - b) < 20 && Math.abs(r - b) < 20;
            
            return isLight && isSimilar;
        }

        function updateQuoteColorMappings() {
            const container = document.getElementById('quoteColorMappings');
            
            if (state.detectedColors.size === 0) {
                container.innerHTML = '<p style="font-size: 0.8rem; color: #888;">No quote colors detected yet.</p>';
                return;
            }
            
            container.innerHTML = '';
            
            for (const color of state.detectedColors) {
                const mapping = document.createElement('div');
                mapping.className = 'quote-mapping';
                mapping.innerHTML = `
                    <div class="color-preview" style="background: ${color};"></div>
                    <span style="font-size: 0.8rem; font-family: monospace;">${color}</span>
                    <select onchange="updateQuoteMapping('${color}', this.value)">
                        <option value="smallquote" ${state.quoteColorMap[color] === 'smallquote' ? 'selected' : ''}>Small Quote</option>
                        <option value="bigquote" ${state.quoteColorMap[color] === 'bigquote' ? 'selected' : ''}>Big Quote</option>
                        <option value="paragraph" ${state.quoteColorMap[color] === 'paragraph' ? 'selected' : ''}>Paragraph</option>
                        <option value="ignore" ${state.quoteColorMap[color] === 'ignore' ? 'selected' : ''}>Ignore</option>
                    </select>
                `;
                container.appendChild(mapping);
            }
        }

        function updateQuoteMapping(color, type) {
            state.quoteColorMap[color] = type;
            
            for (let i = 0; i < state.textBlocks.length; i++) {
                for (let j = 0; j < state.textBlocks[i].length; j++) {
                    const element = state.textBlocks[i][j];
                    if (element.type === 'quote' && element.originalColor === color) {
                        element.quoteType = type === 'ignore' ? 'paragraph' : type;
                        if (type === 'ignore' || type === 'paragraph') {
                            element.type = 'paragraph';
                        }
                    }
                }
            }
            
            updatePreview();
        }

        // ============================================
        // SEARCH & REPLACE
        // ============================================

        function executeReplace() {
            const searchText = document.getElementById('searchInput').value;
            const replaceText = document.getElementById('replaceInput').value;
            
            if (!searchText) return;
            
            state.searchReplaceBackup = JSON.parse(JSON.stringify(state.textBlocks));
            
            for (let i = 0; i < state.textBlocks.length; i++) {
                for (let j = 0; j < state.textBlocks[i].length; j++) {
                    state.textBlocks[i][j].content = state.textBlocks[i][j].content.split(searchText).join(replaceText);
                }
            }
            
            state.cardName = state.cardName.split(searchText).join(replaceText);
            document.getElementById('cardNameInput').value = state.cardName;
            
            document.getElementById('undoBtn').disabled = false;
            updatePreview();
        }

        function undoReplace() {
            if (state.searchReplaceBackup) {
                state.textBlocks = state.searchReplaceBackup;
                state.searchReplaceBackup = null;
                document.getElementById('undoBtn').disabled = true;
                updatePreview();
            }
        }

        // ============================================
        // ODD/EVEN & DETAILS MODE
        // ============================================

        function toggleOddEven() {
            const toggle = document.getElementById('oddEvenToggle');
            toggle.classList.toggle('active');
            state.isOddEvenMode = toggle.classList.contains('active');
            generateStyleEditors();
            updatePreview();
        }

        function toggleDetails() {
            const toggle = document.getElementById('detailsToggle');
            toggle.classList.toggle('active');
            state.isDetailsMode = toggle.classList.contains('active');
            
            const summaryInputs = document.getElementById('summaryInputs');
            summaryInputs.style.display = state.isDetailsMode ? 'block' : 'none';
            
            updateSummaryInputs();
            updatePreview();
        }

        function updateSummaryInputs() {
            const container = document.getElementById('summaryInputs');
            container.innerHTML = '';
            
            if (!state.isDetailsMode) return;
            
            for (let i = 0; i < state.textBlocks.length; i++) {
                const div = document.createElement('div');
                div.className = 'summary-input-group';
                div.innerHTML = `
                    <label>Block ${i + 1}:</label>
                    <input type="text" value="${state.summaryTexts[i] || `Section ${i + 1}`}" onchange="updateSummaryText(${i}, this.value)">
                `;
                container.appendChild(div);
            }
        }

        function updateSummaryText(index, value) {
            state.summaryTexts[index] = value;
            updatePreview();
        }

        // ============================================
        // IMAGE HANDLING
        // ============================================

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                state.imageData = e.target.result;
                updatePreview();
            };
            reader.readAsDataURL(file);
        }

        function removeImage() {
            state.imageData = '';
            updatePreview();
        }

        // ============================================
        // PREVIEW GENERATION
        // ============================================

        function updatePreview() {
            state.cardName = document.getElementById('cardNameInput').value;
            
            if (!state.hasContent && state.textBlocks.length === 0) {
                document.getElementById('previewFrame').innerHTML = '<p style="color: #666; text-align: center; padding: 40px;">Paste content to see preview</p>';
                return;
            }
            
            const html = generatePreviewHTML();
            
            if (state.isEditMode) {
                document.getElementById('editTextarea').value = html;
            } else {
                document.getElementById('previewFrame').innerHTML = html;
            }
        }

        function generatePreviewHTML() {
            const template = templatePresets[state.currentTemplate];
            const structure = template?.structure || 'vertical';
            
            if (structure === 'horizontal') {
                return generateHorizontalLayout();
            } else {
                return generateVerticalLayout();
            }
        }

function generateVerticalLayout() {
    const rootStyle = generateInlineStyle('root_container', { 'font-family': state.globalFont });
    const imageStyle = generateInlineStyle('image_container', { 
        'background-image': state.imageData ? `url(${state.imageData})` : 'none' 
    });
    const contentStyle = generateInlineStyle('content_container');
    const headerStyle = generateInlineStyle('header_container');
    const cardNameStyle = generateInlineStyle('card_name');
    const textContainerStyle = generateInlineStyle('text_container');
    const footerStyle = generateInlineStyle('footer_container');
    const footerTextStyle = generateInlineStyle('footer_text');
    
    const imageHTML = state.imageData ? `<div style="${imageStyle}"></div>` : '';
    const blocksHTML = generateTextBlocksHTML();
    const pillsHTML = generatePillsHTML();
    
    return `<div style="${rootStyle}">
    ${imageHTML}
    <div style="${contentStyle}">
        <div style="${headerStyle}">
            <div style="${cardNameStyle}">${state.cardName}</div>
            <div style="margin-top: 0.5rem;">
                ${pillsHTML}
            </div>
        </div>
        <div style="${textContainerStyle}">
            ${blocksHTML}
        </div>
        <div style="${footerStyle}">
            <span style="${footerTextStyle}">From <a href="https://grimtze.github.io/logarhythm/logarhythm.html">RisuAI</a>, with <a href="https://grimtze.github.io/logarhythm/logarhythm.html">Logarhythm ùÑû</a></span>
        </div>
    </div>
</div>`;
}
function generateHorizontalLayout() {
    const rootStyle = generateInlineStyle('root_container', { 'font-family': state.globalFont });
    const imageStyle = generateInlineStyle('image_container', { 
        'background-image': state.imageData ? `url(${state.imageData})` : "url('https://placehold.co/600x400/EEE/31343C')" 
    });
    const contentStyle = generateInlineStyle('content_container');
    const headerStyle = generateInlineStyle('header_container');
    const cardNameStyle = generateInlineStyle('card_name');
    const textContainerStyle = generateInlineStyle('text_container');
    const footerStyle = generateInlineStyle('footer_container');
    const footerTextStyle = generateInlineStyle('footer_text');
    
    const blocksHTML = generateTextBlocksHTML();
    const pillsHTML = generatePillsHTML();
    
    return `<div style="${rootStyle}">
    <div style="${imageStyle}"></div>
    <div style="${contentStyle}">
        <div style="${headerStyle}">
            <div>
                <div style="${cardNameStyle}">${state.cardName}</div>
                <div style="margin-top: 0.5rem;">
                    ${pillsHTML}
                </div>
            </div>
        </div>
        <div style="${textContainerStyle}">
            ${blocksHTML}
        </div>
        <div style="${footerStyle}">
            <span style="${footerTextStyle}">From RisuAI, with LogarhythmùÑû</span>
        </div>
    </div>
</div>`;
}

        function generateTextBlocksHTML() {
            let blocksHTML = '';
            
            for (let i = 0; i < state.textBlocks.length; i++) {
                const isEven = i % 2 === 1;
                const blockStyleKey = state.isOddEvenMode && isEven ? 'text_block_even' : 'text_block';
                const blockStyle = generateInlineStyle(blockStyleKey);
                
                let blockContent = '';
                
                for (const element of state.textBlocks[i]) {
                    const paraStyle = generateInlineStyle('paragraph');
                    
                    if (element.type === 'paragraph') {
                        blockContent += `<p style="${paraStyle}">${element.content}</p>\n`;
                    } else if (element.type === 'quote') {
                        const quoteStyleKey = element.quoteType === 'smallquote' ? 'smallquote' : 'bigquote';
                        const quoteStyle = generateInlineStyle(quoteStyleKey);
                        blockContent += `<p style="${paraStyle}; ${quoteStyle}">${element.content}</p>\n`;
                    }
                }
                
                if (state.isDetailsMode) {
                    blocksHTML += `
        <details>
            <summary>${state.summaryTexts[i] || `Section ${i + 1}`}</summary>
            <div style="${blockStyle}">
                ${blockContent}
            </div>
        </details>\n`;
                } else {
                    blocksHTML += `
        <div style="${blockStyle}">
            ${blockContent}
        </div>\n`;
                }
            }
            
            return blocksHTML;
        }

        function generateInlineStyle(elementKey, extraStyles = {}) {
            const styles = { ...state.templateStyles[elementKey], ...extraStyles };
            
            return Object.entries(styles)
                .filter(([key, value]) => value !== undefined && value !== null && value !== '')
                .map(([key, value]) => `${key}: ${value}`)
                .join('; ');
        }

        // ============================================
        // EDIT MODE
        // ============================================

        function toggleEditMode() {
            state.isEditMode = !state.isEditMode;
            
            const previewFrame = document.getElementById('previewFrame');
            const editTextarea = document.getElementById('editTextarea');
            const editBtn = document.getElementById('editBtn');
            const previewTitle = document.getElementById('previewTitle');
            
            if (state.isEditMode) {
                previewFrame.classList.add('hidden');
                editTextarea.classList.remove('hidden');
                editTextarea.value = previewFrame.innerHTML;
                editBtn.textContent = 'Preview';
                previewTitle.textContent = 'Edit HTML';
            } else {
                previewFrame.classList.remove('hidden');
                editTextarea.classList.add('hidden');
                editBtn.textContent = 'Edit HTML';
                previewTitle.textContent = 'Preview';
                previewFrame.innerHTML = editTextarea.value;
            }
        }

        function updateFromEdit() {
            // Changes will be applied when switching back to preview
        }

        // ============================================
        // OUTPUT GENERATION
        // ============================================

        function generateOutput() {
            let output;
            
            if (state.isEditMode) {
                output = document.getElementById('editTextarea').value;
            } else {
                output = document.getElementById('previewFrame').innerHTML;
            }
            
            output = formatHTML(output);
            document.getElementById('outputTextarea').value = output;
        }

        function formatHTML(html) {
            let formatted = '';
            let indent = 0;
            const tab = '    ';
            
            html = html.replace(/>\s*</g, '>\n<');
            const lines = html.split('\n');
            
            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                
                if (line.startsWith('</')) {
                    indent = Math.max(0, indent - 1);
                }
                
                formatted += tab.repeat(indent) + line + '\n';
                
                if (line.startsWith('<') && !line.startsWith('</') && !line.endsWith('/>') && !line.includes('</')) {
                    const voidElements = ['br', 'hr', 'img', 'input', 'meta', 'link'];
                    const tagMatch = line.match(/<(\w+)/);
                    if (tagMatch && !voidElements.includes(tagMatch[1].toLowerCase())) {
                        indent++;
                    }
                }
            }
            
            return formatted.trim();
        }

        async function copyOutput(event) {
            const output = document.getElementById('outputTextarea').value;
            
            try {
                await navigator.clipboard.writeText(output);
                
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-success');
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('btn-success');
                    btn.classList.add('btn-primary');
                }, 2000);
            } catch (err) {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard.');
            }
        }
		// ============================================
// PILL MANAGEMENT
// ============================================

function addPill(text = '', bgColor = '#000000', textColor = '#f8f8f2', borderColor = '#4b5563') {
    state.pills.push({
        text: text || 'New Pill',
        bgColor: bgColor,
        textColor: textColor,
        borderColor: borderColor
    });
    renderPills();
    updatePreview();
}

function removePill(index) {
    state.pills.splice(index, 1);
    renderPills();
    updatePreview();
}

function updatePill(index, field, value) {
    if (state.pills[index]) {
        state.pills[index][field] = value;
        renderPills();
        updatePreview();
    }
}

function renderPills() {
    const container = document.getElementById('pillsContainer');
    
    if (state.pills.length === 0) {
        container.innerHTML = '<p style="font-size: 0.8rem; color: #666;">No pills added yet. Click "+ Add Pill" to create one.</p>';
        return;
    }
    
    container.innerHTML = state.pills.map((pill, index) => `
        <div class="pill-editor">
            <input type="text" value="${pill.text}" placeholder="Pill text..." 
                onchange="updatePill(${index}, 'text', this.value)">
            
            <div class="pill-editor-colors">
                <label>BG</label>
                <input type="color" value="${pill.bgColor}" 
                    onchange="updatePill(${index}, 'bgColor', this.value)" title="Background Color">
            </div>
            
            <div class="pill-editor-colors">
                <label>Text</label>
                <input type="color" value="${pill.textColor}" 
                    onchange="updatePill(${index}, 'textColor', this.value)" title="Text Color">
            </div>
            
            <div class="pill-editor-colors">
                <label>Border</label>
                <input type="color" value="${pill.borderColor}" 
                    onchange="updatePill(${index}, 'borderColor', this.value)" title="Border Color">
            </div>
            
            <div class="pill-preview" style="background: ${pill.bgColor}; color: ${pill.textColor}; border: 1px solid ${pill.borderColor};">
                ${pill.text}
            </div>
            
            <button class="btn btn-danger btn-small" onclick="removePill(${index})" style="padding: 4px 8px;">√ó</button>
        </div>
    `).join('');
}

function generatePillsHTML() {
    if (state.pills.length === 0) return '';
    
    return state.pills.map(pill => {
        const style = `background: ${pill.bgColor}; color: ${pill.textColor}; border: 1px solid ${pill.borderColor}; border-radius: 16px; padding: 0.25rem 0.75rem; font-size: 0.8rem; display: inline-block; margin: 0 4px 4px 0;`;
        return `<span style="${style}">${pill.text}</span>`;
    }).join('\n            ');
}
// ============================================
// GRADIENT & BORDER HELPERS
// ============================================

function parseGradientAngle(value) {
    if (!value) return 90;
    const match = value.match(/(\d+)deg/);
    return match ? parseInt(match[1]) : 90;
}

function parseGradientStops(value) {
    if (!value || !value.includes('gradient')) {
        return [
            { color: '#000000', position: 0 },
            { color: '#ffffff', position: 100 }
        ];
    }
    
    const stops = [];
    const regex = /(#[a-fA-F0-9]{6}|#[a-fA-F0-9]{3}|rgba?\([^)]+\))\s*(\d+)?%?/g;
    let match;
    let index = 0;
    
    while ((match = regex.exec(value)) !== null) {
        stops.push({
            color: match[1].startsWith('#') ? match[1] : '#000000',
            position: match[2] ? parseInt(match[2]) : (index === 0 ? 0 : 100)
        });
        index++;
    }
    
    if (stops.length < 2) {
        return [
            { color: '#000000', position: 0 },
            { color: '#ffffff', position: 100 }
        ];
    }
    
    return stops;
}

function generateGradientStops(elementKey, prop, value) {
    const stops = parseGradientStops(value);
    
    return stops.map((stop, index) => `
        <div class="gradient-stop">
            <input type="color" value="${stop.color}" onchange="updateGradient('${elementKey}', '${prop}')">
            <input type="number" value="${stop.position}" min="0" max="100" onchange="updateGradient('${elementKey}', '${prop}')">
            <span>%</span>
            ${stops.length > 2 ? `<button class="btn btn-danger btn-small" style="padding: 2px 6px;" onclick="removeGradientStop('${elementKey}', '${prop}', ${index})">√ó</button>` : ''}
        </div>
    `).join('');
}

function toggleBackgroundType(elementKey, prop, type, container) {
    const solidEditor = container.querySelector('.solid-color-editor');
    const gradientEditor = container.querySelector('.gradient-editor');
    
    if (type === 'solid') {
        solidEditor.style.display = '';
        gradientEditor.style.display = 'none';
        updateTemplateStyle(elementKey, prop, '#000000');
    } else {
        solidEditor.style.display = 'none';
        gradientEditor.style.display = '';
        updateGradient(elementKey, prop);
    }
}

function updateGradient(elementKey, prop) {
    const editor = document.querySelector(`.gradient-editor[data-element="${elementKey}"][data-prop="${prop}"]`);
    if (!editor) return;
    
    const type = editor.querySelector('.gradient-type').value;
    const angle = editor.querySelector('.gradient-angle')?.value || 90;
    const stopElements = editor.querySelectorAll('.gradient-stop');
    
    const stops = [];
    stopElements.forEach(stopEl => {
        const color = stopEl.querySelector('input[type="color"]').value;
        const position = stopEl.querySelector('input[type="number"]').value;
        stops.push(`${color} ${position}%`);
    });
    
    let gradientValue;
    if (type === 'linear') {
        gradientValue = `linear-gradient(${angle}deg, ${stops.join(', ')})`;
        editor.querySelector('.gradient-direction').style.display = '';
    } else {
        gradientValue = `radial-gradient(circle, ${stops.join(', ')})`;
        editor.querySelector('.gradient-direction').style.display = 'none';
    }
    
    // Update preview
    editor.querySelector('.gradient-preview').style.background = gradientValue;
    
    // Update state
    updateTemplateStyle(elementKey, prop, gradientValue);
}

function addGradientStop(elementKey, prop) {
    const currentValue = state.templateStyles[elementKey]?.[prop] || '';
    const stops = parseGradientStops(currentValue);
    
    // Add new stop in the middle
    const newPosition = stops.length > 0 ? Math.round((stops[stops.length - 1].position + stops[0].position) / 2) : 50;
    stops.push({ color: '#888888', position: newPosition });
    stops.sort((a, b) => a.position - b.position);
    
    // Rebuild gradient
    const editor = document.querySelector(`.gradient-editor[data-element="${elementKey}"][data-prop="${prop}"]`);
    const type = editor.querySelector('.gradient-type').value;
    const angle = editor.querySelector('.gradient-angle')?.value || 90;
    
    const stopsStr = stops.map(s => `${s.color} ${s.position}%`).join(', ');
    const gradientValue = type === 'linear' 
        ? `linear-gradient(${angle}deg, ${stopsStr})`
        : `radial-gradient(circle, ${stopsStr})`;
    
    updateTemplateStyle(elementKey, prop, gradientValue);
    generateStyleEditors(); // Rebuild to show new stop
}

function removeGradientStop(elementKey, prop, index) {
    const currentValue = state.templateStyles[elementKey]?.[prop] || '';
    const stops = parseGradientStops(currentValue);
    
    if (stops.length <= 2) return; // Minimum 2 stops
    
    stops.splice(index, 1);
    
    const editor = document.querySelector(`.gradient-editor[data-element="${elementKey}"][data-prop="${prop}"]`);
    const type = editor.querySelector('.gradient-type').value;
    const angle = editor.querySelector('.gradient-angle')?.value || 90;
    
    const stopsStr = stops.map(s => `${s.color} ${s.position}%`).join(', ');
    const gradientValue = type === 'linear' 
        ? `linear-gradient(${angle}deg, ${stopsStr})`
        : `radial-gradient(circle, ${stopsStr})`;
    
    updateTemplateStyle(elementKey, prop, gradientValue);
    generateStyleEditors();
}

function updateBorderStyle(elementKey, prop, container) {
    const width = container.querySelector('input[type="number"]').value;
    const style = container.querySelector('select').value;
    const color = container.querySelector('input[type="color"]').value;
    
    const borderValue = style === 'none' ? 'none' : `${width}px ${style} ${color}`;
    updateTemplateStyle(elementKey, prop, borderValue);
}
        // ============================================
        // INITIALIZATION
        // ============================================

        function init() {
            loadTemplate('vertical_dark');
            updatePresetDropdown();
			renderPills(); 
            
            document.getElementById('presetSelect').addEventListener('change', function() {
                if (this.value) {
                    loadTemplate(this.value);
                    this.value = '';
                }
            });
        }

        init();
    </script>
</body>
</html>
